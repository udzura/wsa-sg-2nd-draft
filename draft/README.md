suEXEC セキュリティモデルをベースにしたコンテナ起動時のバリデーションの提案
==============================================================

## 研究のあらまし

多くのコンテナランタイム[1]は、コンテナを作成するときにスーパーユーザ権限を必要とする。これはコンテナを作成する作業者がそもそも管理者である（＝誰が操作できるか管理できる）場合と比べ、ホスティング環境のようにユーザにコンテナ環境を提供する場合には一層の注意が必要となる。

FastContainer[2]のような場合、ユーザのリクエストに応じて対応するコンテナを立ち上げる。したがって、Nginxなどのウェブサーバがコンテナを起動することになるので、Nginx自体が一定の権限を持っていることが求められる。万が一、不正なクエリなどにより権限を持ったNginxから任意のコンテナを立ち上げ可能となった場合、危ない。

DockerdのようにコンテナランタイムのためのHTTP APIを提供している場合でも、そのAPIデーモンをrootで動かしている場合などでは、同様の問題は考えられる。例えばパターンとしては、稀であろうがDocker HTTP API自体のバグや運用上のパスワード忘れなどのミスが考えられる。

一般にUser Namespaceを用いることで非特権ユーザでコンテナを作成することは可能であるが、非特権ユーザを使う場合であっても後述のsuexecプログラム同様にset-user-id rootされたバイナリが必要となる[3]。

ここで、いわゆる仮想ホスト方式を採用したWebホスティングの基盤の場合、suEXECを利用することで利用者ごとの独立性（この場合、あるユーザの領域が他のユーザからアクセスできない、などの性質）や、ホストのシステム領域へのアクセスができないことを担保することができる[4]。具体的には、ある仮想ホストに紐づくアクセスから実行されるCGIが、apacheのシステムユーザとは別かつドキュメントルートごとに別々のユーザとなって実行されるようになる。こうすることで（sshで別々のユーザとしてログインしているように）プログラムから他のユーザのドキュメントルートや、システム領域への操作ができなくなる。

一方、そのような挙動を実現するために、suexecプログラムはset-user-id rootがされている。これはsetuid/gidを内部で呼び出すために必要な権限であるが、同時に多くの権限を実行バイナリに与えてしまう結果となる。

そのためsuexecプログラムを実行するために様々な制約が課せられている[5]。suexecプログラムはこれらのチェックリストのうち、一つでも満たさないものがある条件においては起動せず、システムに監査ログを吐き出す。

このように仮想ホスト方式において一定の運用実績があるsuEXECセキュリティモデルを、コンテナの実行時の制約に転用できないかということを提案する。

## 前提(1) - コンテナ環境をユーザに提供するにあたり、望ましくない操作について

作成したコンテナ環境をユーザに提供するような場面（ホスティングサービスの提供）を考える。例えばsshdなどのデーモンをコンテナ内部に立ち上げてログインを許可する、APIを用いてアタッチを可能にする、といった形が考えられる。この場合利用者は、アプリケーションのデプロイメントやその他の作業などを実施するために一定の操作の権限が与えられるはずである。その一定の操作の権限の中で、望まない操作ができてしまうとホスティングサービスの提供者としては問題となる。望まない操作の種別を4つにまとめ、それぞれを課題1.〜課題4.とする。

1. コンテナの内部から、コンテナをホストしている親のOSに「脱獄」ができる場合
2. コンテナの内部から、コンテナの「外」が見えたり操作できる場合。コンテナをホストしているOSの情報、同一LANにある秘匿したいホストの情報など
3. コンテナの内部について、サービス提供者が意図しない設定変更やファイルの操作ができる場合
4. コンテナの起動時に、サービス提供者が意図しないコマンド、引数、権限での起動をされる場合

課題1.に関しては利用・提供形態に限らず、コンテナがコンテナとして利用されていると言えるために、そもそも守られるべき点であると考えることもできる。

次に2.と3.に関しては、特にホスティングサービスの提供において、「操作・閲覧できるべき内容」と「操作・閲覧できてはならない内容」の切り分けをしなければならないため、問題となる。この判断基準は、PaaSのようにウェブアプリケーションをホストするのみの場合、VPSに近い環境を提供したい場合、など異なってくる部分もあるが、いずれにせよサービス提供者が意図した切り分けの基準を確実に的ようでき、抜け道を作ってしまわないような技術的な仕組みが求められる。

また4.に関しては、FastContainerアーキテクチャを利用する場合や、FaaSであったりCIサービスでコンテナを作成するような場合のように、必要に応じて起動するようなコンテナでは重要になってくると考える。すなわち、ユーザの何かしらの操作にコンテナの起動というシステムのイベントが強く結びついており、管理者の範囲外でのコントロールができるため、その部分に瑕疵があると望ましくない結果につながるであろう。

ところでホスティングサービスでない、一般のウェブサービスなどにおいても、例えばOSコマンドインジェクションであったり、Webシェルのアップロードであるような脆弱性を契機とした攻撃が考えられる。そのような攻撃が成功した場合、コンテナに対するユーザの操作権限はホスティングでssh環境を提供しているような場合とほぼ同等となる。したがって本原稿の問題意識はホスティングサービスの外側にも通じる。

## 前提(2) - コンテナにおけるセキュリティ強化の仕組みの整理

前提(1)に関連して、それぞれの課題との関係を示しつつ、現在のコンテナランタイム、あるいはコンテナオーケストレーションのレベルで採用されているセキュリティ機構をまとめる。

### a) Kernel User Namespace

Linuxカーネルには名前空間という仕組みがあり、コンテナにおける基本技術である。その中で、OSのユーザとグループIDをホストに対して独立に管理することが可能なUser Namespaceが存在する。

具体的には、ホストから見た特定の1以上のユーザIDを、その名前空間から見たユーザID＝0、rootユーザーとして扱うことができ、当該名前空間の中では、そのrootユーザはrootユーザとしての権限を持ち、コンテナ内部の操作が自由にできる。さらにホストから見た特定の範囲のユーザIDを、そのまま名前空間の中でシフトして利用することができる。

なお、ホストから見て指定された範囲の外側にあるユーザIDは、 `nobody` として扱われる。その名前空間の中では `nobody` の所有するファイルのオウナーになる事は何人たりとも出来ない。

また同等の仕様がグループIDについても存在する。

（TODO: 作図する）

本機構は、コンテナ内部のrootと外部の本物のrootを分離することができるので 課題1.,2. に有効である。一方で原則としてコンテナの中ではrootであるので、3.に関しての効果は小さい。ただし、操作されたくないファイルの所有者をnobodyにし、UNIXパーミッションとしてothersに対してREAD権限のみを与える等の事はできる（そうすると、rootが読めるけど書き込みできないファイルが作成できる）。

### b) Kernel Capability

Linuxには、スーパーユーザ権限を分割し、その一部を付与あるいは剥奪することができる機構がある。その分割されたそれぞれをKernel Capabilityと呼ぶ。現在のカーネル 4.16.5 においてはスーパユーザ権限は 0 ~ 37 の38権限に分割されている(https://elixir.bootlin.com/linux/v4.16.5/source/include/uapi/linux/capability.h)。

コンテナにおいては、例えばDockerにおいてrootユーザーに与えられている権限が非常に限定されていることが知られている。特にchrootなどの実行を禁止できるため、課題1.の対策となるし、例えばtcpdumpを実行する権限を剥奪したり、ファイルオウナーを変更する権限を剥奪することもできるので、課題2.、課題3.への対策にも応用することができる。

逆に、コンテナの特定のバイナリに、システムに必要な一部のFile capability（こと `CAP_NET_BIND_SERVICE` ）を付与することで、コンテナのinitプロセスの所有者をrootでなくすことも可能である。ただしファイルシステムによりFile capabilityをサポートしない点は留意したい。

### c) Seccomp

Linuxには、特定のシステムコールの呼び出しを制限したり、ホワイトリスト形式で許可するものを絞ったり、あるいはトレース/ログ出力（カーネル4.15よりログ出力も可能になった）の契機とすることが可能である。この機構はseccomp(seccomp mode 2)と呼ばれる。

本機構は概ねKernel Capabilityのように利用でき、Dockerにおいてchrootをはじめとした課題1.,2.,3.に有効である。

### d) Mandatory Access Control(AppArmor)

Mandatory Access Controlは、UNIXの古典的なファイル/プロセスのオウナーに基づいた権限制御のさらに上層から、特定のファイルなどの操作権限をコントロールする機構である。

幾つか実装・手法があるが、プロセス単位でのポリシー適用となるAppArmorはコンテナとの相性が良いと考えられる。今回はAppArmorの機能に絞って紹介する。

AppArmorはプログラムのファイル単位、もしくはプロセス単位でセキュリティプロファイルを適用することができる。セキュリティプロファイルの中では、そのプロセスに対して指定したファイルへの読み書き実行、ソケットやネットワークアクセス、Capabilityの発動などを禁止、または監査の指定をすることができる。

AppArmorのそれぞれのプロファイルには二つのモードがある。一つはenforceモードで、実際にプロファイル通り禁止操作を行う。もう一つはcomplainモードであり、禁止された操作をチェックしログに出力するが、禁止自体は行わないモードとなる。

この機構を用いると、コンテナ内部にrootであっても操作できない・閲覧できないファイルを作成することができる。したがって課題2.と3.に対して有効である。特定のバイナリ以外を実行不可能にすることも可能なので、課題4.に生かせるかもしれない。

### e) Service Meshにおけるセキュリティ担保

コンテナ単一ではなく、コンテナ同士の通信においてもセキュリティを考える必要がある。Kubernetes等のオーケストレーション基盤を利用する場合、コンテナ同士の通信とそのルールの操作にあたる概念をサービスメッシュと呼んで層分けし、負荷分散やルーティング、トレーシング、障害時の切り離しなどのオペレーション要件をそのレイヤで実施することが提唱されている。

サービスメッシュの機能として、大きくは以下の3点はセキュリティに関わるものであろう。

* コンテナ内部の通信経路の暗号化
* コンテナ同士のアクセスの制御。例えばWebアプリケーションコンテナ以外からはDBへのアクセスは直接させない、等。いわゆるIaaSのセキュリティグループのようなものを想像されたい
* コンテナ同士、またはコンテナと外界の通信のトレーシング・異常検知

サービスメッシュ自体コンテナの外が存在することが前提となる概念である。従って主に課題2.の対策である。

### f) Rootless/Unprivileged containers(Docker/LXC)

コンテナランタイムを利用してコンテナを作成するには一般に特権が必要である。ただし、特権がなくとも

LXCにおける非特権コンテナは知られた例である。LXCは、User Namespaceの作成には特権が不要であること、そのUser Namespaceでのrootはコンテナ内部での特権を持つことができることを利用して、非特権ユーザであってもコンテナを作成できる。

ただし、一部の操作はどうしても特権が必要となる。具体的にはユーザID/グループIDのマッピングの作成に関する操作と、ネットワークに関する操作であり、それらの操作を単一で実行するプログラムをそれぞれ用意し、バイナリにset-use-id rootを行うことで安全な非特権ユーザでの操作を実現している。

また、Mobyプロジェクトなどのコミッタである須田氏により、特権がなくともruncやcontainerdを経由したコンテナ作成操作を可能にする実装が提案されている(https://qiita.com/AkihiroSuda/items/145b86ec371d21ae42f2#rootless-containers-%E8%87%AA%E5%88%86%E3%81%AE%E5%8F%96%E3%82%8A%E7%B5%84%E3%81%BF)。この実装には、Network Namespaceを分離する際にvethを使えずtapを利用せねばならないなどの課題があることが言及されている。

なお、これら非特権のコンテナ作成自体は、コンテナそのものの権限コントロールではなく、コンテナを起動するプログラムの権限コントロールと考えられる。従って課題4.の対策となる。

### それぞれの位置付け

上述した機構のうちa)〜d)はコンテナランタイム自体の機能として、コンテナのinitプロセスが何であるにもかかわらず汎用的に利用できるものである。e)はコンテナを実際に利用する際のオーケストレーションで問題となる。

f)は場面によっては問題とならないが、先述した通り「外部のユーザの操作によりコンテナの起動がコントロールできる場合」は考慮する必要がある。

（TODO: ここでも図）

## 提案する内容

今回は特に前提(1)における課題4.への対策を強化する意味で、suEXECセキュリティモデル(https://httpd.apache.org/docs/2.4/ja/suexec.html)をベースとしたコンテナ起動時のバリデーションを提案する。

suEXECセキュリティモデルとは、Apache HTTPサーバがCGIあるいはSSIを実行する際に、Apache自体のユーザ ID とは 異なるユーザ ID で実行する際に考慮しているモデルである。Apacheは、自身が立ち上がっているユーザと同じ権限でCGIプログラムなどを実行するのが通常であるが、一方で仮想ホストのように複数のユーザーにホスティング環境を提供する場合、あるユーザと別のユーザの権限が分離できていないと覗き見などの問題がある。そのため、仮想ホストに紐づくユーザごとの権限でプログラムを実施することで、それぞれの仮想ホストの独立性を担保する。なお、場合によりchroot操作なども組み合わせている。

ここで、一般ユーザでApacheを立ち上げた場合は、そのような操作を実行するにはset-user-id rootされたsuexecバイナリを経由しないと実行できない。set-user-id rootされたバイナリには必要以上の特権が付与された状態であるので、不要な越権操作を行わないよう幾つかの権限などのチェックが入り、全てを通過したプログラムのみが実行されるような仕組みがある。

### コンテナの実行モデルにおけるコンテナランタイムの前段プログラム

コンテナの場合、実運用ではコンテナランタイムを実行する契機となるイベントを受け取るデーモンが存在することが多い。

例えばFastContainerにおいては、リクエストを受け取るためのHTTPDが必要で、そのHTTPDが内部でコンテナを起動するモデルが考えられる。具体的実装として、Nginxとngx_mruby、Haconiwaの組み合わせが存在する(松本論文)。また、Dockerにおいてはruncに対するDockerdがその役割を行う。

（TODO: FastContainerの場合とDockerdを利用した場合のそれぞれのOSユーザの関係について作図する）

これらの前段のデーモンはrootユーザ以外で立ち上がることが望ましく、先述した非特権コンテナは利用できる状況が限定されるので、set-user-id rootされたコンテナランタイムを利用したい。そこで、suEXECセキュリティモデルのような権限の検査が有効であると考える。

### 対応の一覧（ver. 0.1）

suEXECセキュリティモデルの20項目について、コンテナの実行時のモデルを鑑みての具体的な制約に対応させている。考慮すべき点などはあるが、現在の対応関係は以下の通りである。

| suEXECセキュリティモデル | コンテナでの相当する実行時制約 |
| ------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. wrapper を実行しているユーザはこのシステムの正当なユーザか?                              | setuid化されたコンテナランタイムを実行するユーザが正当なユーザであるか                                                                                                                    |
| 2. wrapper が適切な数の引数で呼び出されたか?                                                | コンテナランタイムの引数の数が正しいか。あるいは、引数にできるファイルなど条件をより厳密にすべきかもしれない  |
| 3. この正当なユーザは wrapper の実行を許可されているか?                                     | コンテナランタイムを実行するユーザがホワイトリストにいるか                                                                                                                                |
| 4 対象の CGI、SSIプログラムが安全でない階層の参照をしているか?                              | PID=1のプログラムがrootfsの配下に存在するか。実際chrootしてからexecするはずなので上のファイルを参照できないとは思うが                                                                     |
| 5. 対象となるユーザ名は正当なものか?                                                        | コンテナのPID=1のユーザ名が正当か。この辺りについては、本来User Namespaceも考慮しないといけないだろう                                                                                     |
| 6. 対象となるグループ名は正当なものか?                                                      | コンテナのPID=1のグループ名が正当か                                                                                                                                                       |
| 7. 目的のユーザはスーパーユーザではないか?                                                  | コンテナのPID=1がスーパーユーザでないか。コンテナの用件により禁止してしまう場合                                                                                                           |
| 8. 対象となるユーザ ID は、最小の ID 番号よりも大きいか?                                    | コンテナのPID=1が指定された最小のUIDより大きいか。システムユーザになってしまうことを防ぐため                                                                                              |
| 9. 対象となるグループはスーパーユーザのグループでは ないか?                                 | コンテナのPID=1がスーパーユーザのグループでないか。                                                                                                                                       |
| 10. 対象となるグループ ID は最小の ID 番号よりも大きいか?                                   | コンテナのPID=1が指定された最小のGIDより大きいか。UIDと同様。                                                                                                                                                                               |
| 11. wrapper が正常に対象となるユーザとグループになれるか?                                   | コンテナランタイムが適切に、コンテナのPID=1プロセスを指定したユーザにできるか                                                                                                             |
| 12. CGI/SSI プログラムが置かれているディレクトリに移動 (change directory) できるか?        | rootfsとして指定したディレクトリがそもそも存在するか                                                                                                                                      |
| 13. ディレクトリが Apache のドキュメントツリー内にあるか?                                   | rootfsに出来るディレクトリが、特定のディレクトリの配下に存在するか。逆に言うと、suEXEC を参考にするのであればrootfsの場所を特定ディレクトリの下に限定する仕様が必要                       |
| 14. ディレクトリを他のユーザが書き込めるようになって いないか?                              | rootfsを他のユーザが書き込めるようになっていないか。それはね。。。                                                                                                                        |
| 15. 対象となる CGI/SSI プログラムは存在するか?                                              | PID=1のプログラムが存在するか。                                                                                                                                                           |
| 16. 対象となる CGI/SSI プログラムファイルが他アカウントから 書き込めるようになっていないか? | PID=1のプログラムが他アカウントから書き込めるようになっていないか。                                                                                                                       |
| 17. 対象となる CGI/SSI プログラムが setuid または setgid されていないか?                    | PID=1のプログラムが setuid または setgid されていないか。ただし、シェルを実行するコンテナもあるだろうので常に有効にすべきかは悩ましい。                                                                                         |
| 18. 対象となるユーザ/グループがプログラムの ユーザ/グループと同じか?                        | PID=1のプログラムの所有者とPID=1のプログラムのファイルの所有者が一致するか。これもコンテナ的には悩ましい点がある。デーモンは特権ポートを使うため、通常プログラムのファイルがroot所有となっている。CAP_NET_BINDだけ与えるか？など検討する |
| 19. 安全な動作を保証するための環境変数クリアが可能か?                                       | PID=1のプログラムを実行するにあたり、環境変数を初期化しているか？もしくは、ホワイトリストにない環境変数を指定された場合でも消しているか？ PATHなども安全にする                            |
| 20. 対象となる CGI/SSI プログラムを exec して実行できるか?                                  | そもそもPID=1に指定したプログラムが実行できるか                                                                                                                                          |

### 実装の方針

これらの20種類の制約に関して、コンテナランタイムにおいて近似する制約をまとめて、それぞれのグループ毎に有効/無効を選択できる形が現実的ではないかと考える。グルーピングの例を示す。

何をどうまとめるかについては純粋に利用者の便宜のためであるが、例えば上記の 14. と 16. は `HACONIWA_FS_NONWRITABLE_BY_OTHER` のような名前のフラグでまとめた方が都合がいいのではないかと考える。UID/GIDのチェックなどもある程度まとめた形にした方が便利であろう。など。

(TBD!!!!!!!!!!!)

分類以外の、詳細な実装の方針を示す。

* 必要なビルドオプションを指定するとその機構が有効になる
* オプションが多いほど、そのコンテナランタイムで作るコンテナはセキュアになる
* 何を有効にするかについては組み合わせが可能であるべきだが、ビルド段階での組み合わせの指定という形をとる

### 実際の実装

Haconiwaというコンテナランタイムにおいて、先述したようなホスティング環境でのセキュリティ強化の目的で [幾つかPull Request を出している](https://github.com/haconiwa/haconiwa/pull/135) 。

ちなみに最初に実装したものは、バイナリとHacofileの所有者の一致を検査するオプションである。上記で対応するものは強いて言えば 2. であろう。Haconiwaがバイナリ自身の他にファイル - Hacofile - をとって起動するのでその考慮が必要となるためである。この検査をすることで、例えばnginxユーザが所有するHacofileではコンテナは作成できないので、nginxユーザの権限のみでは任意のコンテナを作成できる状況には陥らなくなる。

Haconiwaにおける実装の場合、ビルド環境がRubyであるので、ビルドオプションをDSLで記述でき、十分記述性を高くすることが可能である点はメリットである。他実装であればYAMLなどの形式でも構わないだろう。

----

ということでブラッシュアップをし、引き続き実装などをやっていきたい。

## 参考資料

* [1] コンテナランタイム、コンテナなどの用語の用法は [近藤うちお他, Haconiwa: プログラムによる、組み立て可能性と拡張性を持つLinuxコンテナ, 
情報処理学会第80回全国大会講演論文集, 2018](https://rand.pepabo.com/papers/ipsj-nc80-udzura.pdf) に従っている
* [2] [松本亮介他, 第38回インターネットと運用技術研究会, 2017](https://rand.pepabo.com/papers/iot38-proceeding-matsumotory.pdf)
* [3] [Linux Container - LXC - セキュリティ](https://linuxcontainers.org/ja/lxc/security/)
* [4] [松本亮介他, Webサーバの高集積マルチテナントアーキテクチャと運用技術, 電子情報通信学会論文誌BのVolume J101-B No.1, 2018](http://search.ieice.org/bin/summary.php?id=j101-b_1_16&category=B&year=2018&lang=J&abst=)
* [5] [suEXEC サポート](https://httpd.apache.org/docs/2.4/ja/suexec.html)
