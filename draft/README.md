suEXEC セキュリティモデルをベースにしたコンテナ起動時のバリデーションの提案
==============================================================

## 研究のあらまし

多くのコンテナランタイム[1]は、コンテナを作成するときにスーパーユーザ権限を必要とする。これはコンテナを作成する作業者がそもそも管理者である（＝誰が操作できるか管理できる）場合と比べ、ホスティング環境のようにユーザにコンテナ環境を提供する場合には一層の注意が必要となる。

FastContainer[2]のような場合、ユーザのリクエストに応じて対応するコンテナを立ち上げる。したがって、Nginxなどのウェブサーバがコンテナを起動することになるので、Nginx自体が一定の権限を持っていることが求められる。万が一、不正なクエリなどにより権限を持ったNginxから任意のコンテナを立ち上げ可能となった場合、危ない。

DockerdのようにコンテナランタイムのためのHTTP APIを提供している場合でも、そのAPIデーモンをrootで動かしている場合などでは、同様の問題は考えられる。例えばパターンとしては、稀であろうがDocker HTTP API自体のバグや運用上のパスワード忘れなどのミスが考えられる。

（TODO: FastContainerの場合とDockerdを利用した場合のそれぞれのOSユーザの関係について作図する）

一般にUser Namespaceを用いることで非特権ユーザでコンテナを作成することは可能であるが、非特権ユーザを使う場合であっても後述のsuexecプログラム同様にset-user-id rootされたバイナリが必要となる[3]。

ここで、いわゆる仮想ホスト方式を採用したWebホスティングの基盤の場合、suEXECを利用することで利用者ごとの独立性（この場合、あるユーザの領域が他のユーザからアクセスできない、などの性質）や、ホストのシステム領域へのアクセスができないことを担保することができる[4]。具体的には、ある仮想ホストに紐づくアクセスから実行されるCGIが、apacheのシステムユーザとは別かつドキュメントルートごとに別々のユーザとなって実行されるようになる。こうすることで（sshで別々のユーザとしてログインしているように）プログラムから他のユーザのドキュメントルートや、システム領域への操作ができなくなる。

一方、そのような挙動を実現するために、suexecプログラムはset-user-id rootがされている。これはsetuid/gidを内部で呼び出すために必要な権限であるが、同時に多くの権限を実行バイナリに与えてしまう結果となる。

そのためsuexecプログラムを実行するために様々な制約が課せられている[5]。suexecプログラムはこれらのチェックリストのうち、一つでも満たさないものがある条件においては起動せず、システムに監査ログを吐き出す。

このように仮想ホスト方式において一定の運用実績があるsuEXECセキュリティモデルを、コンテナの実行時の制約に転用できないかということを提案する。

## 前提(1) - コンテナ環境をユーザに提供するにあたり、望ましくない操作について

作成したコンテナ環境をユーザに提供するような場面（ホスティングサービスの提供）を考える。例えばsshdなどのデーモンをコンテナ内部に立ち上げてログインを許可する、APIを用いてアタッチを可能にする、といった形が考えられる。この場合利用者は、アプリケーションのデプロイメントやその他の作業などを実施するために一定の操作の権限が与えられるはずである。その一定の操作の権限の中で、望まない操作ができてしまうとホスティングサービスの提供者としては問題となる。望まない操作の種別を4つにまとめ、それぞれを課題1.〜課題4.とする。

1. コンテナの内部から、コンテナをホストしている親のOSに「脱獄」ができる場合
2. コンテナの内部から、コンテナの「外」が見えたり操作できる場合。コンテナをホストしているOSの情報、同一LANにある秘匿したいホストの情報など
3. コンテナの内部について、サービス提供者が意図しない設定変更やファイルの操作ができる場合
4. コンテナの起動時に、サービス提供者が意図しないコマンドであったり、意図しない引数での起動をされる場合

課題1.に関しては利用・提供形態に限らず、コンテナの仕様として守られるべき点である。

次に2.と3.に関しては、特にホスティングサービスの提供において、「操作・閲覧できるべき内容」と「操作・閲覧できてはならない内容」の切り分けをしなければならないため、問題となる。この判断基準は、PaaSのようにウェブアプリケーションをホストするのみの場合、VPSに近い環境を提供したい場合、など異なってくる部分もあるが、いずれにせよサービス提供者が意図した切り分けの基準を確実に的ようでき、抜け道を作ってしまわないような技術的な仕組みが求められる。

また4.に関しては、FastContainerアーキテクチャを利用する場合のように、必要に応じて起動するようなコンテナでは重要になってくると考える。すなわち、ユーザの何かしらの操作にコンテナの起動というシステムのイベントが強く結びついており、管理者の範囲外でのコントロールができるため、その部分に瑕疵があると望ましくない結果につながるであろう。

ところでホスティングサービスでない、一般のウェブサービスなどにおいても、例えばOSコマンドインジェクションであったり、Webシェルのアップロードであるような脆弱性を契機とした攻撃が考えられる。そのような攻撃が成功した場合、コンテナに対するユーザの操作権限はホスティングでssh環境を提供しているような場合とほぼ同等となる。したがって本原稿の問題意識はホスティングサービスの外側にも通じる。

## 前提(2) - コンテナにおけるセキュリティ強化の仕組みの整理

前提(1)に関連して、それぞれの課題との関係を示しつつ、現在のコンテナランタイム、あるいはコンテナオーケストレーションのレベルで採用されているセキュリティ機構をまとめる。

### Kernel User Namespace


### Kernel Capability


### Seccomp


### Mandatory Access Control(AppArmor)

### Service Meshにおけるセキュリティ

### Rootless/Unprivileged containers(Docker/LXC)


### それぞれの位置付け

ところで、現在Linuxコンテナのセキュリティの強化の機構には、Linux Capability、seccomp、MAC(SELinux/AppArmor/TOMOYO他)、あるいはオーケストレーターのサポートにもよるがサービスメッシュでの対応が挙げられる。新しい軸としてsuEXECセキュリティモデルを基にしたものが採用できるかもしれない。

（TODO: ここでも図）

## 提案する内容

今回は前提(1)における課題2.,3.,4.への対策を強化する意味で、suEXECセキュリティモデルをベースとしたコンテナ起動時のバリデーションを提案する。

suEXECセキュリティモデルとは、

### 対応の一覧（ver. 0.1）

suEXECセキュリティモデルの20項目について、コンテナの実行時のモデルを鑑みての具体的な制約に対応させている。考慮すべき点などはあるが、現在の対応関係は以下の通りである。

| suEXECセキュリティモデル | コンテナでの相当する実行時制約 |
| ------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. wrapper を実行しているユーザはこのシステムの正当なユーザか?                              | setuid化されたコンテナランタイムを実行するユーザが正当なユーザであるか                                                                                                                    |
| 2. wrapper が適切な数の引数で呼び出されたか?                                                | コンテナランタイムの引数の数が正しいか。あるいは、引数にできるファイルなど条件をより厳密にすべきかもしれない  |
| 3. この正当なユーザは wrapper の実行を許可されているか?                                     | コンテナランタイムを実行するユーザがホワイトリストにいるか                                                                                                                                |
| 4 対象の CGI、SSIプログラムが安全でない階層の参照をしているか?                              | PID=1のプログラムがrootfsの配下に存在するか。実際chrootしてからexecするはずなので上のファイルを参照できないとは思うが                                                                     |
| 5. 対象となるユーザ名は正当なものか?                                                        | コンテナのPID=1のユーザ名が正当か。この辺りについては、本来User Namespaceも考慮しないといけないだろう                                                                                     |
| 6. 対象となるグループ名は正当なものか?                                                      | コンテナのPID=1のグループ名が正当か                                                                                                                                                       |
| 7. 目的のユーザはスーパーユーザではないか?                                                  | コンテナのPID=1がスーパーユーザでないか。コンテナの用件により禁止してしまう場合                                                                                                           |
| 8. 対象となるユーザ ID は、最小の ID 番号よりも大きいか?                                    | コンテナのPID=1が指定された最小のUIDより大きいか。システムユーザになってしまうことを防ぐため                                                                                              |
| 9. 対象となるグループはスーパーユーザのグループでは ないか?                                 | コンテナのPID=1がスーパーユーザのグループでないか。                                                                                                                                       |
| 10. 対象となるグループ ID は最小の ID 番号よりも大きいか?                                   | コンテナのPID=1が指定された最小のGIDより大きいか。UIDと同様。                                                                                                                                                                               |
| 11. wrapper が正常に対象となるユーザとグループになれるか?                                   | コンテナランタイムが適切に、コンテナのPID=1プロセスを指定したユーザにできるか                                                                                                             |
| 12. CGI/SSI プログラムが置かれているディレクトリに移動 (change directory) できるか?        | rootfsとして指定したディレクトリがそもそも存在するか                                                                                                                                      |
| 13. ディレクトリが Apache のドキュメントツリー内にあるか?                                   | rootfsに出来るディレクトリが、特定のディレクトリの配下に存在するか。逆に言うと、suEXEC を参考にするのであればrootfsの場所を特定ディレクトリの下に限定する仕様が必要                       |
| 14. ディレクトリを他のユーザが書き込めるようになって いないか?                              | rootfsを他のユーザが書き込めるようになっていないか。それはね。。。                                                                                                                        |
| 15. 対象となる CGI/SSI プログラムは存在するか?                                              | PID=1のプログラムが存在するか。                                                                                                                                                           |
| 16. 対象となる CGI/SSI プログラムファイルが他アカウントから 書き込めるようになっていないか? | PID=1のプログラムが他アカウントから書き込めるようになっていないか。                                                                                                                       |
| 17. 対象となる CGI/SSI プログラムが setuid または setgid されていないか?                    | PID=1のプログラムが setuid または setgid されていないか。ただし、シェルを実行するコンテナもあるだろうので常に有効にすべきかは悩ましい。                                                                                         |
| 18. 対象となるユーザ/グループがプログラムの ユーザ/グループと同じか?                        | PID=1のプログラムの所有者とPID=1のプログラムのファイルの所有者が一致するか。これもコンテナ的には悩ましい点がある。デーモンは特権ポートを使うため、通常プログラムのファイルがroot所有となっている。CAP_NET_BINDだけ与えるか？など検討する |
| 19. 安全な動作を保証するための環境変数クリアが可能か?                                       | PID=1のプログラムを実行するにあたり、環境変数を初期化しているか？もしくは、ホワイトリストにない環境変数を指定された場合でも消しているか？ PATHなども安全にする                            |
| 20. 対象となる CGI/SSI プログラムを exec して実行できるか?                                  | そもそもPID=1に指定したプログラムが実行できるか                                                                                                                                          |

### 実装の方針

これらの20種類の制約に関して、コンテナランタイムにおいて近似する制約をまとめて、それぞれのグループ毎に有効/無効を選択できる形が現実的ではないかと考える。グルーピングの例を示す。



### 実際の実装

Haconiwaというコンテナランタイムにおいて、先述したようなホスティング環境でのセキュリティ強化の目的で [幾つかPull Request を出している](https://github.com/haconiwa/haconiwa/pull/135) 。

ちなみに最初に実装したものは、バイナリとHacofileの所有者の一致を検査するオプションである。上記で対応するものは強いて言えば 2. であろう（Haconiwaがバイナリ自身の他にファイル - Hacofile - をとって起動するのでその考慮が必要となる）。この検査をすることで、例えばnginxユーザが所有するHacofileではコンテナは作成できないので、nginxユーザの権限のみでは任意のコンテナを作成できる状況には陥らなくなる。

本モデルについて、今後も整頓して一通り実装したいと考えている。設計方針としては以下である。

* 似たような/まとめて有効にしたい項目をまとめる
* 必要なビルドオプションを指定するとその機構が有効になる
* オプションが多いほど、そのコンテナランタイムで作るコンテナはセキュアになる
* 何を有効にするかについては組み合わせが可能であるべきだが、ビルド段階での組み合わせの指定という形をとる
   * mrubyであるので、ビルドオプションをDSLで記述でき、十分記述性は高いと考える

何をどうまとめるかについては純粋に利用者の便宜のためであるが、例えば上記の 14. と 16. は `HACONIWA_FS_NONWRITABLE_BY_OTHER` のような名前のフラグでまとめた方が都合がいいのではないかと考える。UID/GIDのチェックなどもある程度まとめた形にした方が便利であろう。など。

----

ということでブラッシュアップをし、引き続き実装などをやっていきたい。

## 参考資料

* [1] コンテナランタイム、コンテナなどの用語の用法は [近藤うちお他, Haconiwa: プログラムによる、組み立て可能性と拡張性を持つLinuxコンテナ, 
情報処理学会第80回全国大会講演論文集, 2018](https://rand.pepabo.com/papers/ipsj-nc80-udzura.pdf) に従っている
* [2] [松本亮介他, 第38回インターネットと運用技術研究会, 2017](https://rand.pepabo.com/papers/iot38-proceeding-matsumotory.pdf)
* [3] [Linux Container - LXC - セキュリティ](https://linuxcontainers.org/ja/lxc/security/)
* [4] [松本亮介他, Webサーバの高集積マルチテナントアーキテクチャと運用技術, 電子情報通信学会論文誌BのVolume J101-B No.1, 2018](http://search.ieice.org/bin/summary.php?id=j101-b_1_16&category=B&year=2018&lang=J&abst=)
* [5] [suEXEC サポート](https://httpd.apache.org/docs/2.4/ja/suexec.html)
